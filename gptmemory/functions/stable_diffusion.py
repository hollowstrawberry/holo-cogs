
import logging
import asyncio
import discord
from typing import Any, Optional, Tuple
from dataclasses import dataclass, field
from redbot.core import commands

from gptmemory.schema import ToolCall, Function, Parameters
from gptmemory.functions.base import FunctionCallBase

log = logging.getLogger("gptmemory.stablediffusion")


@dataclass
class ImageGenParams:
    prompt: str
    negative_prompt: Optional[str] = None
    style: Optional[str] = None
    width: Optional[int] = None
    height: Optional[int] = None
    cfg: Optional[float] = None
    sampler: Optional[str] = None
    scheduler: Optional[str] = None
    steps: Optional[int] = None
    seed: int = -1
    variation: int = 0
    variation_seed: int = -1
    checkpoint: Optional[str] = None
    vae: Optional[str] = None
    lora: str = ""
    subseed: int = -1
    subseed_strength: float = 0.0
    init_image: bytes = field(default_factory=bytes)
    denoising: Optional[float] = None


class StableDiffusionFunctionCall(FunctionCallBase):
    schema = ToolCall(
        Function(
            name="generate_stable_diffusion",
            description="Generate an image with Stable Diffusion. Optionally, adjusts an existing image.",
            parameters=Parameters(
                properties={
                    "existing": {
                        "type": "string",
                        "description": "The filename of an existing image to revise."
                    },
                    "prompt": {
                        "type": "string",
                        "description": "The prompt for image generation. Uses booru tags instead of sentences."
                    },
                    "negative_prompt": {
                        "type": "string",
                        "description": "Additional terms you don't want to appear in the image."
                    },
                    "resolution": {
                        "type": "string",
                        "description": "Image resolution. Not compatible with an existing image.",
                        "enum": ["square", "portrait", "landscape"]
                    },
                },
                required=["prompt"],
            )))

    async def find_attachment(self, filename: str) -> Tuple[bool, Optional[discord.Message]]:
        messages = [message async for message in self.ctx.channel.history(limit=20)]
        if self.ctx.message and self.ctx.message.reference and self.ctx.message.reference.message_id:
            quoted = await self.ctx.channel.fetch_message(self.ctx.message.reference.message_id)
            messages.append(quoted)
        for message in messages:
            for attachment in message.attachments:
                if attachment.filename == filename and self.ctx.guild:
                    return (message.author.id == self.ctx.guild.me.id, message)
        return (False, None)

    async def run(self, arguments: dict) -> str:
        existing = arguments.get("existing", "")
        prompt = arguments.get("prompt", "")
        negative_prompt_extra = arguments.get("negative_prompt", "")
        aspect_ratio = arguments.get("resolution", "")

        if not prompt:
            return "[No prompt provided]"
        aimage: Optional[commands.Cog] = self.ctx.bot.get_cog("AImage")
        if not aimage:
            return "[`aimage` cog not installed, please notify the bot owner]"
        imagescanner: Optional[commands.Cog] = self.ctx.bot.get_cog("ImageScanner")
        if not imagescanner:
            return "[`imagescanner` cog not installed, please notify the bot owner]"
        
        if existing:
            sent_by_me, message = await self.find_attachment(existing)
            if not message:
                return "[Existing image not found]"
            if not sent_by_me:
                return "[Existing image was not generated by the bot, so it can't be revised]"
            
            metadata: dict[str, Any] = await imagescanner.grab_metadata_dict(message) # type: ignore
            width, height = [int(d) for d in metadata.get("Size", "1024x1024").split("x")]

            # add negative tags that weren't already in the existing negative prompt
            negative_prompt = metadata.get("Negative Prompt", "")
            if not negative_prompt:
                negative_prompt = negative_prompt_extra
            elif negative_prompt_extra:
                tags = [tag.strip() for tag in negative_prompt_extra.split(",")]
                for tag in tags:
                    if tag not in negative_prompt:
                        negative_prompt += f", {tag}"

            params = ImageGenParams(
                prompt=prompt,
                negative_prompt=negative_prompt,
                cfg=float(metadata.get("CFG scale", 5)),
                checkpoint=metadata.get("Model", ""),
                width=width,
                height=height,
                sampler=metadata.get("Sampler", ""),
                scheduler=metadata.get("Schedule type", ""),
                seed=int(metadata.get("Seed", -1)),
                subseed=int(metadata.get("Variation seed", -1)),
                subseed_strength=float(metadata.get("Variation seed strength", 0)),
                steps=int(metadata.get("Steps", 30)),
                vae=metadata.get("VAE", metadata.get("vae", ""))
            )
        else:
            if aspect_ratio.lower() == "square":
                width, height = 1024, 1024
            elif aspect_ratio.lower() == "landscape":
                width, height = 1216, 832
            elif aspect_ratio.lower() == "portrait":
                width, height = 832, 1216
            else:
                width, height = None, None

            # add negative tags that weren't already in the default negative prompt
            default_negative_prompt = await aimage.config.guild(self.ctx.guild).negative_prompt() # type: ignore
            negative_prompt = ""
            if negative_prompt_extra:
                tags = [tag.strip() for tag in negative_prompt_extra.split(",")]
                negative_prompt = ", ".join([tag.strip() for tag in tags if tag.strip() not in default_negative_prompt])

            params = ImageGenParams(
                prompt=prompt,
                negative_prompt=negative_prompt or None,
                width=width,
                height=height
            )

        message_content = f"Requested at {self.ctx.message.jump_url} by {self.ctx.author.mention}"
        task = aimage.generate_image(self.ctx, params=params, message_content=message_content) # type: ignore
        asyncio.create_task(task)

        return f"[Image generation started successfully]"
